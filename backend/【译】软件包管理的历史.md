> 本文源自 Fedora RPM Guide

# 软件包管理的历史

1991 年，一位刚毕业的芬兰年轻人搞到了个新玩具：一台 Intel 386 电脑。

没过几周，这位年轻人就开始讨厌电脑自带的 MS-DOS 系统了——因为这个系统对他使用电脑做了过多的限制，而他讨厌限制。于是他就想装一个新的、用起来更爽的操作系统——不是 Minix 那种学习用的迷你系统，而是一个有着丰富特性、功能强大的完整操作系统。

在发现那时的世上并没有免费又强大的操作系统后，该少侠遂决定要自己整一个。今天，这个 Linus Torvalds 一时兴起搞的小系统已经成为了极为成功和重要的 Linux 。

Linux 成功实现了从一个人的个人项目，到一个应用极为广泛的全功能操作系统的转变。而与此同时，Linux 也面临着任何全新操作系统必须面对的问题——其中之一便是各种软件包的安装、管理方式，例如如何安全地安装、卸载、升级软件包而不把系统搞炸。



## 1. 安装、卸载和升级应用程序

在包括 Windows、Unix、Linux 在内的绝大多数操作系统中，应用程序都由一些文件组成，用户需要在运行应用程序之前把这些文件放到文件系统中的特定地方，然后程序才能跑起来。

在没有包管理器的情况下，用户如果想成功安装程序，需要解决一系列的麻烦事：

首先是文件权限问题：各种类 Unix OS（比如 Linux ）都是多用户系统，所以 OS 必须能追踪文件的所有者。这些 OS 都提供了文件权限系统，以便管理者对各种用户对于文件的权限进行控制，因此在安装应用时需要把应用程序的各种文件根据需要拷贝到权限合适的目录中，并要对各个文件配置合适的权限并指明所有者。

其次是软件的卸载和升级问题：安装好的软件需要能够安全、独立地卸载和升级。通常情况下，升级就是卸载掉旧的然后重新装上新的——只是需要注意在卸载旧版本前保留各种配置文件，装好新版本软件后再把这些文件放回去。

诸如此类的各种问题，让类 Unix OS 中的软件包安装过程变得非常麻烦——但更棘手的是，类 Unix 系统的软件通常都是以源代码的形式发布的，如果用户想要装一个软件就需要在拿到软件的源码包后自己解压源码、进行编译前的配置（ configure ），然后再编译成可执行的二进制文件。接下来，用户需要把该应用程序的各个部分（刚编好的二进制、文档、配置文件、资源文件等）复制粘贴到他们该在的目录中，然后手动配置好这些文件的权限等。以 Apache Web Server 为例：用户需要先搞到代码、把这玩意编译出来，然后建立一个用于存放日志的文件夹，接着为服务器创建一个专用的用户（这可以提高安全性），最后还需要手动测试费了这么大劲装上的程序是不是真的装好了。

这太麻烦了。不久，以二进制包形式发布的应用程序流行了起来，这种软件包帮用户省下了编译的麻烦，但剩下的安装、配置、测试等工作还需要用户手工完成。

与已经足够麻烦的安装相比，卸载也并没有轻松到哪里去。卸载差不多是安装的逆过程——这意味着那些繁琐的步骤也要反过来再做一遍——还以上面 Web 服务器的例子来说，用户要删掉手工创建的特殊用户（如果还记得的话）、要手工删除各处的文件（如果还记得的话）……如果没删干净，那这些零碎又无用还占空间的软件残骸就会一直留在电脑中。

升级软件就更麻烦了——用户需要手工备份配置文件，然后用新编的高版本软件的各种组件一个个换掉老版本的。

这简直太卧槽了，要是这些麻烦事能自动搞定就好了——于是，各种工具诞生了。



## 2. 安装的曙光

其实，要手工上面那些工作并不难，只是麻烦。可，任何不算困难的麻烦事在规模变大 100 倍之后都会成为灾难。拿 Fedora 举例来说，要完整安装该系统需要用到约 3000 条命令，处理超过 160000（16万，不用数了） 个文件。手工完成这个大工程显然是不现实的。再举一个小点的例子：电子邮件应用 Postfix 包含约 275 个文件，这些文件分散在十几二十个不同的目录中……你可以想象一下如何纯手工来安装和卸载这么样的一个应用程序。

为了让这一切轻松起来，人们做了很多的努力，想出了不少办法。

### 2.1 应用层工具

早期的某些操作系统（比如 MS-DOS ）选择放弃治疗，不提供系统内建的软件管理工具。于是人们只有两种方法装软件：一是像上面描述过的那样，靠着复制粘贴手工硬装；二是应用程序自带安装工具来安装（更常见一些）。

要卸载软件同样有两种方法，其一还是和之前一样，一个个手工删除；其二则是用应用程序自带的卸载工具删除。软件升级的情况也差不多。

> Windows XP 之后的系统会维护一个已安装应用的数据库，来帮助管理各种程序

### 2.2 系统内建工具

另外一些系统觉得自己还可以挣扎一下，于是提供了内建的软件管理工具。这些工具可以用于在系统中安装软件，至少在一定程度上把之前的纯手工复制、配置等过程自动化。通常情况下，这些工具在安装好软件之后还会记录这些软件各种文件的安装位置等信息，保持对安装过的文件的追踪，方便之后自动删除时使用。

这些内建的工具可以大致分为两类：一类专注于管理安装过程，把软件安装的各个步骤自动化，但还保留手工操作的空间。此类工具常见于各种 BSD 系统，常见的是 `ports` 和 `packages`

FreeBSD 和 OpenBSD 用的是 ports 。ports 是一个工具集，提供了一系列增强版的 Unix 软件构建工具，能够把标准的开源软件构建安装过程自动化，并提供追踪功能。ports 用户想要装软件仍要进行下载源码包、解压、配置（configure）、编译、安装的过程，不过其中的很多步骤都可以用 ports 实现自动化进行，而且 ports 也能在一定程度上实现对文件的追踪。但 ports 并没有提供更多的高级功能：如搜索已经安装的软件包、查看安装过的软件包包含的文件等，也没有升级已安装软件包的功能（但用 ports 安装的软件也还是可以用 ports 卸载掉的），这些缺陷是 ports 这类【以简化编译过程为主的】工具共性的问题。

另外一些系统管理工具则不那么关注安装软件的编译过程，而是着重关注已编译软件最终安装到系统上的各种文件，保持对文件的记录和追踪。

举例来说：System V Unix 包管理软件支持绝大多数的商用 Unix 系统（如 Solaris ）完全不管软件的构建过程，但会维护一个系统数据库，在其中追踪每一个应用的每一个文件。

如果想要用 System V 工具来安装软件，用户需要先编译好软件，然后准备一个记录了该软件要装到系统中的所有文件的列表：该列表中需要包含各种文件的安装位置以及对应的权限、所有者等信息。然后运行一系列的命令来检查这个列表，这些命令会找到列表中的文件，最终把这些文件和列表一起打成一个压缩包。然后，用户就可以把这个压缩包拷贝到各种运行着 System V 的机器中，然后用 System V 软件管理命令（通常是 `pkgadd` ）来安装该包。`pkgadd` 会解压压缩包，再按照列表把所有的文件放到它们该在的地方，设置好权限和所有者。最后， `pkgadd` 会把该文件列表存入一个系统维护的已安装文件数据库中，实现对该包文件的追踪。

有了这类工具的帮助，用户就能够简单地安装和卸载应用程序了。系统级的文件数据库还能够提供应用程序文件的搜索和定位功能。然而，这类工具同样存在局限性——其在软件编译的配置（configure）阶段不如 FreeBSD 的 ports 那样灵活。



## 3. Linux 软件管理工具：包（ Packages ）

最初，Linux 没有任何的软件管理工具——在那个早期的蛮荒时代，用户想要安装 Linux 需要首先在一个其他的操作系统（比如 Minix ）下进行交叉编译，然后手动将各种 Linux 程序复制粘贴到合适的地方，耐心又小心地搭起一个刚好能用的系统。随着 Linux 逐渐成熟， Linux 上也出现了各种软件管理工具——现在的每个 Linux 发行版都自带了包管理工具，这些工具各不相同，但都保有着上面两类工具的灵魂。

Gentoo Linux （http://www.gentoo.org/） 的包管理工具名为 Portage ，该工具和 FreeBSD 的 ports 很像。和 ports 一样，Portage 为软件的编译和安装提供了强大的控制功能，提供了一系列能够自动化下载、编译软件源码的脚本。

与 Gentoo 相对，现在已经凉透了的 deepLinux 使用了名为 `deep-package` 的管理工具。该工具的目标是成为 Solaris `pkgadd` 等工具的完整开源实现。和 `pkgadd` 一样，`deep-package` 完全不关注软件编译，而只关心软件安装和文件追踪部分的工作。

除了这两种极端情况之外，各种 Linux 发行版主要采用的软件管理工具的思路介于上述两者之间。绝大多数 Linux 软件管理工具提供了类似于 FreeBSD ports 的编译工具，同时也使用类似 System V 的方法将编译好的文件打成一个包——该包通常包含所有的软件相关文件，以及一个提供了所有这些文件元数据的脚本，用于管理工具安装和管理这些文件。

一般情况下，一个包就是一个应用程序。例如， Postfix 软件包包含了 275 个文件和一个指定这 275 个文件都该放在什么目录中、都应该有哪些权限、所有者应该是谁的脚本。用户只需要一条命令，就能够解压该包、使用脚本将包内的文件放到他们该在的地方并完成相关设置。

此外，绝大多数 Linux 软件管理工具都维护了一个自己的数据库，这样就能够追踪所有使用软件管理工具安装的应用程序以及它们的文件了，最终实现软件卸载、升级的自动化——当用户想要卸载一个装好了的程序时，软件管理工具就能够根据数据库中对于该程序的文件记录来安全地删除它。

以完整安装 Fedora 为例： Fedora 的软件包管理工具会维护一个包含系统中全部软件的文件的数据库，每当用户装好一个新的程序，这个数据库就会把新装程序的各种文件信息加到数据库中。这个数据库就是实现系统软件管理的关键组件。

各种各样的 Linux 软件管理工具在不同程度上帮用户减轻了安装、卸载、升级软件包的负担，本书聚焦于其中的一款工具：RPM 包管理器（RPM Package Manager, RPM 是递归缩写）

最初，RPM 是由 RedHat 开发的，所以 RPM 的意思是 “ RedHat Package Manager ”，但随着越来越多的其他发行版（甚至非 Linux 发行版的其他系统）也开始用 RPM 来管理软件，因此 RPM 的含义也就改为了现在的 RPM Package Manager。

RPM 系统提供了管理应用程序所需的所有功能，其维护了一个已安装软件包及其版本的数据库，支持安装、卸载、升级软件包，还支持从源代码 RPM 包编译二进制 RPM 包

> 译注：RPM 包分为两种，一种是 SRPM 即 源码 RPM 包，另一种是二进制 RPM 包。前者包含了应用程序的源代码和编译、安装所需的配置文件；另一种是二进制 RPM 包，其包含编译好的软件，能够直接安装。后者可以直接安装，而 RPM 工具能够将前者编译、构建为后者



## 4. 小结

现代操作系统有大量复杂的应用程序，想要自由而安全地升级、安装、卸载软件包，就需要系统能够追踪所有的软件文件。这样的需求就催生了一系列的软件包管理工具。





